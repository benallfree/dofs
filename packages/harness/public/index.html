<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Durable Object File System Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #181818;
      }
      #terminal {
        height: 100vh;
        width: 100vw;
      }
    </style>
  </head>
  <body>
    <div id="terminal"></div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script>
      const term = new window.Terminal({
        theme: { background: '#181818', foreground: '#e0e0e0' },
        fontFamily: 'monospace',
        fontSize: 16,
        cursorBlink: true,
      })
      term.open(document.getElementById('terminal'))
      term.write('Connected to Durable Object File System! Type "help" for commands.\r\n$ ')
      let buffer = ''
      let history = []
      let historyIndex = -1
      let autocompleteState = null // {candidates, prefix, insertPos, cycleIndex, lastBuffer}
      let cwd = '/'
      function resolvePath(inputPath) {
        if (!inputPath || inputPath === '.') return cwd
        if (inputPath.startsWith('/')) return inputPath.replace(/\/+/g, '/')
        let parts = (cwd + '/' + inputPath).split('/').filter(Boolean)
        let stack = []
        for (let part of parts) {
          if (part === '.') continue
          if (part === '..') stack.pop()
          else stack.push(part)
        }
        return '/' + stack.join('/')
      }
      function updatePrompt() {
        term.write(`${cwd} $ `)
      }
      const allowedCommands = {
        help: () =>
          'Allowed commands: help, echo, date, ls, open, upload, rm, cd, pwd, cat, mkdir, rmdir, mv, ln -s, stat',
        echo: (args) => args.join(' '),
        date: () => new Date().toString(),
        pwd: () => cwd,
        cd: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) {
            cwd = '/'
            return
          }
          const res = await fetch(`/api/stat?path=${encodeURIComponent(path)}`)
          if (!res.ok) return `cd: ${args[0]}: No such file or directory`
          const stat = await res.json()
          if (!stat || typeof stat !== 'object') {
            return `cd: ${args[0]}: stat error`
          }
          if (!stat.isDirectory) return `cd: ${args[0]}: Not a directory`
          cwd = path
          return
        },
        ls: async (args) => {
          const path = resolvePath(args[0] || '.')
          try {
            const res = await fetch(`/api/ls?path=${encodeURIComponent(path)}`)
            if (!res.ok) return 'Error: could not list directory'
            const stats = await res.json()
            function modeStr(mode, isDir) {
              if (mode == null) return '??????????'
              const types = isDir ? 'd' : '-'
              const perms = [
                mode & 0o400 ? 'r' : '-',
                mode & 0o200 ? 'w' : '-',
                mode & 0o100 ? 'x' : '-',
                mode & 0o040 ? 'r' : '-',
                mode & 0o020 ? 'w' : '-',
                mode & 0o010 ? 'x' : '-',
                mode & 0o004 ? 'r' : '-',
                mode & 0o002 ? 'w' : '-',
                mode & 0o001 ? 'x' : '-',
              ].join('')
              return types + perms
            }
            function humanSize(size) {
              if (size == null) return '?'
              if (size < 1024) return size + 'B'
              if (size < 1024 * 1024) return (size / 1024).toFixed(1).replace(/\.0$/, '') + 'K'
              if (size < 1024 * 1024 * 1024) return (size / (1024 * 1024)).toFixed(1).replace(/\.0$/, '') + 'M'
              return (size / (1024 * 1024 * 1024)).toFixed(1).replace(/\.0$/, '') + 'G'
            }
            function mtimeStr(mtime) {
              if (!mtime) return '?'
              const d = new Date(mtime)
              const mon = d.toLocaleString('en-US', { month: 'short' })
              const day = d.getDate().toString().padStart(2, ' ')
              const time = d.toTimeString().slice(0, 5)
              return `${mon} ${day} ${time}`
            }
            let maxMode = 10,
              maxNlink = 1,
              maxUid = 1,
              maxGid = 1,
              maxSize = 1,
              maxMtime = 12
            stats.forEach((f) => {
              if (!f.error) {
                maxMode = Math.max(maxMode, modeStr(f.mode, f.isDirectory).length)
                maxNlink = Math.max(maxNlink, (f.nlink ?? 1).toString().length)
                maxUid = Math.max(maxUid, (f.uid ?? '?').toString().length)
                maxGid = Math.max(maxGid, (f.gid ?? '?').toString().length)
                maxSize = Math.max(maxSize, humanSize(f.size).length)
                maxMtime = Math.max(maxMtime, mtimeStr(f.mtime).length)
              }
            })
            function padR(str, len) {
              str = String(str)
              return str.padEnd(len, ' ')
            }
            function padL(str, len) {
              str = String(str)
              return str.padStart(len, ' ')
            }
            const lines = stats.map((f) => {
              if (f.error)
                return `${padR('?', maxMode)} ${padL('?', maxNlink)} ${padR('?', maxUid)} ${padR('?', maxGid)} ${padL('?', maxSize)} ${padR('?', maxMtime)} ${f.name} (error)`
              return [
                padR(modeStr(f.mode, f.isDirectory), maxMode),
                padL(f.nlink ?? 1, maxNlink),
                padR(f.uid ?? '?', maxUid),
                padR(f.gid ?? '?', maxGid),
                padL(humanSize(f.size), maxSize),
                padR(mtimeStr(f.mtime), maxMtime),
                f.name + (f.isDirectory ? '/' : ''),
              ].join(' ')
            })
            return lines.join('\r\n')
          } catch (e) {
            return 'Error: ' + e.message
          }
        },
        cat: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: cat <file>'
          const res = await fetch(`/api/file?path=${encodeURIComponent(path)}`)
          if (!res.ok) return `cat: ${args[0]}: No such file`
          const text = await res.text()
          return text
        },
        open: (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: open <file>'
          const url = `/api/file?path=${encodeURIComponent(path)}`
          window.open(url, '_blank')
          return `Opened ${path} in new window.`
        },
        upload: () => {
          return new Promise((resolve) => {
            const input = document.createElement('input')
            input.type = 'file'
            input.style.display = 'none'
            document.body.appendChild(input)
            input.addEventListener('change', () => {
              const file = input.files[0]
              if (!file) {
                document.body.removeChild(input)
                resolve('No file selected.')
                return
              }
              const formData = new FormData()
              formData.append('file', file)
              const xhr = new XMLHttpRequest()
              xhr.open('POST', `/api/upload?path=${encodeURIComponent(cwd)}`)
              xhr.onload = () => {
                document.body.removeChild(input)
                if (xhr.status === 200) {
                  resolve(`Uploaded: ${file.name}`)
                } else {
                  resolve(`Upload failed: ${xhr.statusText}`)
                }
              }
              xhr.onerror = () => {
                document.body.removeChild(input)
                resolve('Upload failed: network error')
              }
              xhr.send(formData)
            })
            input.click()
          })
        },
        rm: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: rm <file>'
          const res = await fetch(`/api/rm?path=${encodeURIComponent(path)}`, { method: 'POST' })
          if (!res.ok) return `Error: could not remove ${args[0]}`
          return `Removed ${args[0]}`
        },
        mkdir: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: mkdir <dir>'
          const res = await fetch(`/api/mkdir?path=${encodeURIComponent(path)}`, { method: 'POST' })
          if (!res.ok) return `Error: could not create directory ${args[0]}`
          return `Created directory ${args[0]}`
        },
        rmdir: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: rmdir <dir>'
          const res = await fetch(`/api/rmdir?path=${encodeURIComponent(path)}`, { method: 'POST' })
          if (!res.ok) return `Error: could not remove directory ${args[0]}`
          return `Removed directory ${args[0]}`
        },
        mv: async (args) => {
          if (args.length < 2) return 'Usage: mv <src> <dest>'
          const src = resolvePath(args[0])
          const dest = resolvePath(args[1])
          const res = await fetch(`/api/mv?src=${encodeURIComponent(src)}&dest=${encodeURIComponent(dest)}`, {
            method: 'POST',
          })
          if (!res.ok) return `Error: could not move ${args[0]}`
          return `Moved ${args[0]} to ${args[1]}`
        },
        'ln -s': async (args) => {
          if (args.length < 2) return 'Usage: ln -s <target> <link>'
          const target = resolvePath(args[0])
          const path = resolvePath(args[1])
          const res = await fetch(
            `/api/symlink?target=${encodeURIComponent(target)}&path=${encodeURIComponent(path)}`,
            { method: 'POST' }
          )
          if (!res.ok) return `Error: could not symlink ${args[1]}`
          return `Symlinked ${args[1]} -> ${args[0]}`
        },
        stat: async (args) => {
          const path = resolvePath(args[0])
          if (!args[0]) return 'Usage: stat <file|dir>'
          const res = await fetch(`/api/stat?path=${encodeURIComponent(path)}`)
          if (!res.ok) return `Error: could not stat ${args[0]}`
          const stat = await res.json()
          return JSON.stringify(stat, null, 2)
        },
      }
      const allCommands = Object.keys(allowedCommands)
      async function getCompletions(cmd, argPrefix, cwd = '/') {
        // Only complete for file args (not command name)
        let path = argPrefix
        let base = ''
        if (!path || path.endsWith('/')) {
          base = path || cwd
          path = ''
        } else {
          const idx = path.lastIndexOf('/')
          if (idx >= 0) {
            base = resolvePath(path.slice(0, idx + 1))
            path = path.slice(idx + 1)
          } else {
            base = cwd
          }
        }
        try {
          const res = await fetch(`/api/ls?path=${encodeURIComponent(base || '/')}`)
          if (!res.ok) return []
          const stats = await res.json()
          return stats
            .filter((f) => !f.error && f.name.startsWith(path))
            .map((f) => f.name + (f.isDirectory ? '/' : ''))
            .sort()
        } catch {
          return []
        }
      }
      function writePrompt() {
        term.write(`${cwd} $ `)
      }
      term.onData(async (e) => {
        if (e === '\r') {
          // Enter
          const [cmd, ...args] = buffer.trim().split(' ')
          term.writeln('')
          if (buffer.trim().length > 0) {
            history.push(buffer)
            historyIndex = history.length
          }
          if (allowedCommands[cmd]) {
            const result = allowedCommands[cmd](args)
            if (result instanceof Promise) {
              const awaited = await result
              if (awaited !== undefined && awaited !== null) term.writeln(awaited)
            } else {
              if (result !== undefined && result !== null) term.writeln(result)
            }
            if (cmd === 'cd') {
              writePrompt()
              buffer = ''
              return
            }
          } else if (cmd.length > 0) {
            term.writeln('Command not found')
          }
          buffer = ''
          writePrompt()
        } else if (e === '\u007F') {
          // Backspace
          if (buffer.length > 0) {
            buffer = buffer.slice(0, -1)
            term.write('\b \b')
          }
        } else if (e === '\u001b[A') {
          // Up arrow
          if (history.length > 0 && historyIndex > 0) {
            historyIndex--
            // Clear current line
            term.write(`\r\x1b[K$ `)
            buffer = history[historyIndex]
            term.write(buffer)
          }
        } else if (e === '\u001b[B') {
          // Down arrow
          if (history.length > 0 && historyIndex < history.length - 1) {
            historyIndex++
            term.write(`\r\x1b[K$ `)
            buffer = history[historyIndex]
          } else if (historyIndex === history.length - 1) {
            historyIndex++
            term.write(`\r\x1b[K$ `)
            buffer = ''
          }
        } else if (e === '\t') {
          // TAB
          // Find word to complete (after last space, or command)
          let parts = buffer.split(/ +/)
          let isCmd = buffer.trim().length === 0 || buffer.match(/^\s*\S*$/)
          let insertPos = buffer.length
          let prefix = ''
          if (isCmd) {
            prefix = parts[0] || ''
            insertPos = buffer.length
            // Complete command
            let candidates = allCommands.filter((c) => c.startsWith(prefix))
            if (!candidates.length) return
            if (!autocompleteState || autocompleteState.lastBuffer !== buffer) {
              autocompleteState = { candidates, prefix, insertPos, cycleIndex: 0, lastBuffer: buffer }
            } else {
              autocompleteState.cycleIndex = (autocompleteState.cycleIndex + 1) % candidates.length
            }
            let common = candidates[0]
            for (let c of candidates) {
              let i = 0
              while (i < common.length && c[i] === common[i]) i++
              common = common.slice(0, i)
            }
            let toInsert = candidates.length === 1 ? candidates[0] : common
            // Rewrite line
            term.write(`\r\x1b[K$ ` + toInsert)
            buffer = toInsert
            if (candidates.length > 1 && autocompleteState.cycleIndex === 0) {
              term.writeln('\r\n' + candidates.join('  '))
              term.write(`$ ` + toInsert)
            } else if (candidates.length > 1) {
              let pick = candidates[autocompleteState.cycleIndex]
              term.write(`\r\x1b[K$ ` + pick)
              buffer = pick
            }
            return
          } else {
            // Complete file/dir
            let argIdx = parts.length - 1
            prefix = parts[argIdx] || ''
            insertPos = buffer.lastIndexOf(prefix)
            let candidates = await getCompletions(parts[0], prefix, cwd)
            if (!candidates.length) return
            if (!autocompleteState || autocompleteState.lastBuffer !== buffer) {
              autocompleteState = { candidates, prefix, insertPos, cycleIndex: 0, lastBuffer: buffer }
            } else {
              autocompleteState.cycleIndex = (autocompleteState.cycleIndex + 1) % candidates.length
            }
            let common = candidates[0]
            for (let c of candidates) {
              let i = 0
              while (i < common.length && c[i] === common[i]) i++
              common = common.slice(0, i)
            }
            let toInsert = candidates.length === 1 ? candidates[0] : common
            let newBuffer = buffer.slice(0, insertPos) + toInsert
            // Rewrite line
            term.write(`\r\x1b[K$ ` + newBuffer)
            buffer = newBuffer
            if (candidates.length > 1 && autocompleteState.cycleIndex === 0) {
              term.writeln('\r\n' + candidates.join('  '))
              term.write(`$ ` + newBuffer)
            } else if (candidates.length > 1) {
              let pick = candidates[autocompleteState.cycleIndex]
              let newBuffer2 = buffer.slice(0, insertPos) + pick
              term.write(`\r\x1b[K$ ` + newBuffer2)
              buffer = newBuffer2
            }
            return
          }
        } else if (e === '\u0003') {
          // Ctrl+C
          term.write('^C\r\n$ ')
          buffer = ''
        } else if (e >= ' ' && e <= '~') {
          // Printable
          buffer += e
          term.write(e)
        }
        autocompleteState = null
      })
    </script>
  </body>
</html>
